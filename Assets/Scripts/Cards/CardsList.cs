// ------------------------------------------------------------------------------
//  <autogenerated>
//      This code was generated by a tool.
//      Mono Runtime Version: 4.0.30319.1
// 
//      Changes to this file may cause incorrect behavior and will be lost if 
//      the code is regenerated.
//  </autogenerated>
// ------------------------------------------------------------------------------
using System;
using System.Collections;
using UnityEngine;

namespace Cards
{
	public class CardListNode{
		public Card card;
		public CardListNode next;

		public CardListNode(Card card){
			this.card = card;
			next = null;
		}
	}

	//this list will be used to store all the used cards and their status
	public class CardsList
	{

		public CardListNode first;
		public CardListNode next;
		public int Count;

		public CardsList ()
		{
			first = null;
		}

		//this method should be called when the card position doesn't matter for the list
		public void addFreeCard(Card card){
		}

		public void removeCardAt(Card card){
			//remember to deal with the next variable in this method
		}



		//each time a card is added, it should be added in the right list, so we don't really need to check their type
		//however, we need to check if the cards turn counts is lower or higher than the ones in the existing list
		//if it is lower, it should appear before them
		public void addCard(Card card){
			Count++;
			if (first == null)
				this.first = new CardListNode (card);
			else {
				CardListNode next = first;
				CardListNode newCardNode = new CardListNode(card);
				CardListNode last = null;
				bool done = false;
				while (next != null ) {
					if(next.card.turnCount > card.turnCount){
						newCardNode.next = next;
						if(last != null) last.next = newCardNode;
						next = null;
					}
					else if(next.next == null){
						next.next = newCardNode;
						next = null;
					}
					else {
						last = next;
						next = next.next;
					}
				}
			}

		}

		public void updateList(){
			CardListNode next = first;
			bool done = false;
			while (this.first != null && !done) {
				next.card.turnCount -= 1;
				if(next.card.turnCount <= 0){
					this.first = next.next;
				}
				else done = true;
			}
		}

		public int getAttribute(bool damage = false, bool guard = false, bool move = false){
			CardListNode next = first;
			int attribute = 0;
			while (next != null) {
				if(damage && damage == next.card.damageCard) attribute+=next.card.damage;
				else if(guard && guard == next.card.guardCard) attribute+=next.card.guard;
				else if(move && move == next.card.moveCard) {
					attribute+=next.card.movement;
				}
				next = next.next;
			}

			return attribute;
		}

		public Card popFirstCard(){
			Count--;
			Card pop = first.card;
			first = first.next;

			return pop;
		}

		public void decreaseAttribute(int decrease, bool damage = false, bool guard = false, bool move = false){
			CardListNode next = first;
			while (decrease >0 && next != null) {
				Debug.Log (string.Format ("Decrease is {0}", decrease));
					if(damage && damage == next.card.damageCard) decrease -= next.card.damage;
					else if(guard && guard == next.card.guardCard) decrease -=next.card.guard;
					else if(move && move == next.card.moveCard) decrease -=next.card.movement;
					next = next.next;
			}
			first = next;
		}

		public Card getNextCard(){
			next = next != null? (next.next != null ? next.next : first) : first;
			CardListNode n = next;
			return n.card;
		}
	}
}

